<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--                                             -->
<!-- Author: KaliVeda Development team           -->
<!--                                             -->
<!--   Date: Tue Feb 28 17:22:44 2017            -->
<!--                                             -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<title>KVString</title>
<meta name="rating" content="General" />
<meta name="objecttype" content="Manual" />
<meta name="keywords" content="software development, oo, object oriented, linux, c++, html, indra, fazia" />
<meta name="description" content="KaliVeda - An Object-Oriented Toolkit for Analysis of Heavy-Ion Collisions" />
<link rel="stylesheet" type="text/css" href="ROOT.css" id="ROOTstyle" />
<script type="text/javascript" src="ROOT.js"></script>
</head>
<body  onload="javascript:SetValuesFromCookie();">
<img src="htmldoc_banner.png" height="180px" width="700px" alt="KaliVeda logo"/>
<a name="TopOfPage"></a>
<script type="text/javascript">WriteFollowPageBox('class KVString','libKVMultiDetbase','KVString.h');</script>
<div id="toplinks">
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Quick Links:</span>
<a class="descrheadentry" href="http://indra.in2p3.fr/KaliVedaDoc">KaliVeda v1.10/13</a>
<a class="descrheadentry" href="http://root.cern.ch">ROOT Homepage</a>
<a class="descrheadentry" href="./ClassIndex.html">Class Index</a>
<a class="descrheadentry" href="./ClassHierarchy.html">Class Hierarchy</a></div>
<script type="text/javascript">
function onSearch() {
var s='http://www.google.com/search?q=%s+site%3A%u+-site%3A%u%2Fsrc%2F+-site%3A%u%2Fexamples%2F';
var ref=String(document.location.href).replace(/https?:\/\//,'').replace(/\/[^\/]*$/,'').replace(/\//g,'%2F');
window.location.href=s.replace(/%u/ig,ref).replace(/%s/ig,escape(document.searchform.t.value));
return false;}
</script>
<form id="searchform" name="searchform" onsubmit="return onSearch()" action="javascript:onSearch();" method="post">
<input name="t" size="30" value="Search documentation..." onfocus="if (document.searchform.t.value=='Search documentation...') document.searchform.t.value='';"></input>
<a id="searchlink"  title="www.google.com"  href="javascript:onSearch();" onclick="return onSearch()">Search</a></form>
</div>
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Source:</span>
<a class="descrheadentry" href="src/KVString.h.html">header file</a>
<a class="descrheadentry" href="src/KVString.cxx.html">source file</a>
<a class="descrheadentry" href="https://github.com/kaliveda-dev/kaliveda/blob/1.10/KVMultiDet/base/KVString.h">viewVC header</a> <a class="descrheadentry" href="https://github.com/kaliveda-dev/kaliveda/blob/1.10/KVMultiDet/base/KVString.cpp">viewVC source</a> 
</div></div>
<div class="descrhead"><div class="descrheadcontent">
<span class="descrtitle">Sections:</span>
<a class="descrheadentry" href="#KVString:description">class description</a> 
<a class="descrheadentry" href="#KVString:Function_Members">function members</a>
<a class="descrheadentry" href="#KVString:Data_Members">data members</a>
<a class="descrheadentry" href="#KVString:Class_Charts">class charts</a>
</div></div>
</div>
<div class="location">
<a class="locationlevel" href="index.html">KaliVeda v1.10/13</a>
 &#187; <a class="locationlevel" href="./KVMULTIDET_Index.html">KVMULTIDET</a>
 &#187; <a class="locationlevel" href="./KVMULTIDET_BASE_Index.html">BASE</a>
 &#187; <a class="locationlevel" href="#TopOfPage">KVString</a>
</div>
<div class="dropshadow"><div class="withshadow"><h1><a name="KVString:description"></a>class KVString: public TString</h1>
<div class="classdescr">
<pre>
 <a href="./KVString.html">KVString</a>

 Allows backwards compatibility with ROOT v3.10/02 onwards.
 <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::<a href="./#TString:Tokenize" title="TObjArray* TString::Tokenize(const TString&amp; delim) or overloads">Tokenize</a> and <a href="./#TString:IsDigit" title="Bool_t TString::IsDigit()">IsDigit</a> methods are added here if they don't exist
 in the version of ROOT being used.

 <a href="./#TString:IsFloat" title="Bool_t TString::IsFloat()">IsFloat</a>() method is added: returns <a href="./ListOfTypes.html#bool">true</a> if string is a floating-point number, i.e. if it
              has any of following formats (only first one returns <a href="./ListOfTypes.html#Bool_t">kTRUE</a> with <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::<a href="./#TString:IsDigit" title="Bool_t TString::IsDigit()">IsDigit</a>()):
      64320
      6.4320  6,4320
      6.43e20   6.43E20 6,43e20
      6.43e-20  6.43E-20 6,43e-20

 Also <a href="./#TString:Atoi" title="Int_t TString::Atoi()">Atoi</a>() and <a href="./#TString:Atof" title="Double_t TString::Atof()">Atof</a>() are extended to include the following possibilities:

 <a href="./#TString:Atoi" title="Int_t TString::Atoi()">Atoi</a>(): with string=<span class="string">"123 456"</span>, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::<a href="./#TString:Atoi" title="Int_t TString::Atoi()">Atoi</a>() gives value=123
              <a href="./KVString.html">KVString</a>::<a href="./#TString:Atoi" title="Int_t TString::Atoi()">Atoi</a>() gives value=123456
 <a href="./#TString:Atof" title="Double_t TString::Atof()">Atof</a>(): with string=<span class="string">"12,34"</span>, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::<a href="./#TString:Atof" title="Double_t TString::Atof()">Atof</a>() gives value=12
              <a href="./KVString.html">KVString</a>::<a href="./#TString:Atof" title="Double_t TString::Atof()">Atof</a>() gives value=12.34

 <a href="./KVString.html#KVString:Begin" title="void KVString::Begin(TString delim)">Begin</a>(), <a href="./KVString.html#KVString:Next" title="KVString KVString::Next(Bool_t strip_whitespace=kFALSE)">Next</a>() and <a href="./KVString.html#KVString:End" title="Bool_t KVString::End()">End</a>() can be used to loop over items in
 a string separated by the delimiter character given as argument
 to <a href="./KVString.html#KVString:Begin" title="void KVString::Begin(TString delim)">Begin</a>().

 Example:
   <a href="./KVString.html">KVString</a> str(<span class="string">"First | Second | Third"</span>);
   str.<a href="./KVString.html#KVString:Begin" title="void KVString::Begin(TString delim)">Begin</a>(<span class="string">"|"</span>);
   while( !str.<a href="./KVString.html#KVString:End" title="Bool_t KVString::End()">End</a>() ){
     <a href="./ListOfTypes.html#ostream">cout</a> &lt;&lt; str.<a href="./KVString.html#KVString:Next" title="KVString KVString::Next(Bool_t strip_whitespace=kFALSE)">Next</a>().<a href="./#TString:Data" title="const char* TString::Data()">Data</a>() &lt;&lt; endl;
   }

 This will give the following output:

 <a href="./#TString:First" title="Ssiz_t TString::First(char c) or overloads">First</a>
  Second
  Third

 or, if <a href="./KVString.html#KVString:Next" title="KVString KVString::Next(Bool_t strip_whitespace=kFALSE)">Next</a> is called with argument strip_whitespace=<a href="./ListOfTypes.html#Bool_t">kTRUE</a>,

 <a href="./#TString:First" title="Ssiz_t TString::First(char c) or overloads">First</a>
 Second
 Third


</pre></div>
</div></div>

<div id="functions">
<h2><a id="KVString:Function_Members"></a>Function Members (Methods)</h2>
<div class="access" id="funcpubl"><b>public:</b>
<table class="func" id="tabfuncpubl" cellspacing="0">
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#KVString:KVString">KVString</a>()</td></tr>
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#KVString:KVString@1">KVString</a>(<span class="keyword">const</span> <a href="./ListOfTypes.html#Char_t">Char_t</a>* s)</td></tr>
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#KVString:KVString@2">KVString</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s)</td></tr>
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#KVString:KVString@3">KVString</a>(<span class="keyword">const</span> <a href="./KVString.html">KVString</a>&amp; s)</td></tr>
<tr class="func"><td class="funcret"></td><td class="funcname"><a class="funcname" href="#KVString:KVString@4">KVString</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> value, <a href="./ListOfTypes.html#Double_t">Double_t</a> error)</td></tr>
<tr class="func"><td class="funcret"> virtual</td><td class="funcname"><a class="funcname" href="#KVString:_KVString">~KVString</a>()</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Append"><span class="baseclass">TString::</span>Append</a>(<span class="keyword">const</span> <span class="keyword">char</span>* cs)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Append@2"><span class="baseclass">TString::</span>Append</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Append@1"><span class="baseclass">TString::</span>Append</a>(<span class="keyword">const</span> <span class="keyword">char</span>* cs, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Append@3"><span class="baseclass">TString::</span>Append</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Append@4"><span class="baseclass">TString::</span>Append</a>(<span class="keyword">char</span> c, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> rep = 1)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Double_t">Double_t</a></td><td class="funcname"><a class="funcname" href="#TString:Atof"><span class="baseclass">TString::</span>Atof</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TString:Atoi"><span class="baseclass">TString::</span>Atoi</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Long64_t">Long64_t</a></td><td class="funcname"><a class="funcname" href="#TString:Atoll"><span class="baseclass">TString::</span>Atoll</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">static <a href="./KVString.html">KVString</a></td><td class="funcname"><a class="funcname" href="#KVString:BaseConvert">BaseConvert</a>(<span class="keyword">const</span> <a href="./KVString.html">KVString</a>&amp; s_in, <a href="./ListOfTypes.html#Int_t">Int_t</a> base_in, <a href="./ListOfTypes.html#Int_t">Int_t</a> base_out)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#KVString:Begin">Begin</a>(<a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a> delim) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:BeginsWith"><span class="baseclass">TString::</span>BeginsWith</a>(<span class="keyword">const</span> <span class="keyword">char</span>* s, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp = kExact) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:BeginsWith@1"><span class="baseclass">TString::</span>BeginsWith</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; pat, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp = kExact) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Capacity"><span class="baseclass">TString::</span>Capacity</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Capacity@1"><span class="baseclass">TString::</span>Capacity</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Chop"><span class="baseclass">TString::</span>Chop</a>()</td></tr>
<tr class="func"><td class="funcret">static TClass*</td><td class="funcname"><a class="funcname" href="#KVString:Class">Class</a>()</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TString:Clear"><span class="baseclass">TString::</span>Clear</a>()</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">int</span></td><td class="funcname"><a class="funcname" href="#TString:CompareTo"><span class="baseclass">TString::</span>CompareTo</a>(<span class="keyword">const</span> <span class="keyword">char</span>* cs, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp = kExact) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">int</span></td><td class="funcname"><a class="funcname" href="#TString:CompareTo@1"><span class="baseclass">TString::</span>CompareTo</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; st, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp = kExact) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:Contains@2"><span class="baseclass">TString::</span>Contains</a>(<span class="keyword">const</span> TRegexp&amp; pat) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:Contains@3"><span class="baseclass">TString::</span>Contains</a>(TPRegexp&amp; pat) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:Contains"><span class="baseclass">TString::</span>Contains</a>(<span class="keyword">const</span> <span class="keyword">char</span>* s, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp = kExact) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:Contains@1"><span class="baseclass">TString::</span>Contains</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; pat, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp = kExact) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a></td><td class="funcname"><a class="funcname" href="#TString:Copy"><span class="baseclass">TString::</span>Copy</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TString:CountChar"><span class="baseclass">TString::</span>CountChar</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> c) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="#TString:Data"><span class="baseclass">TString::</span>Data</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#KVString:End">End</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:EndsWith"><span class="baseclass">TString::</span>EndsWith</a>(<span class="keyword">const</span> <span class="keyword">char</span>* pat, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp = kExact) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:EqualTo"><span class="baseclass">TString::</span>EqualTo</a>(<span class="keyword">const</span> <span class="keyword">char</span>* cs, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp = kExact) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:EqualTo@1"><span class="baseclass">TString::</span>EqualTo</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; st, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp = kExact) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TString:FillBuffer"><span class="baseclass">TString::</span>FillBuffer</a>(<span class="keyword">char</span>*&amp; buffer) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./KVString.html">KVString</a>&amp;</td><td class="funcname"><a class="funcname" href="#KVString:FindCommonCharacters">FindCommonCharacters</a>(<span class="keyword">const</span> TCollection*, <span class="keyword">const</span> <span class="keyword">char</span> bug = <span class="string">'*'</span>)</td></tr>
<tr class="func"><td class="funcret"><a href="./KVString.html">KVString</a>&amp;</td><td class="funcname"><a class="funcname" href="#KVString:FindCommonTitleCharacters">FindCommonTitleCharacters</a>(<span class="keyword">const</span> TCollection*, <span class="keyword">const</span> <span class="keyword">char</span> bug = <span class="string">'*'</span>)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:First"><span class="baseclass">TString::</span>First</a>(<span class="keyword">char</span> c) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:First@1"><span class="baseclass">TString::</span>First</a>(<span class="keyword">const</span> <span class="keyword">char</span>* cs) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TString:Form"><span class="baseclass">TString::</span>Form</a>(<span class="keyword">const</span> <span class="keyword">char</span>* fmt)</td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a></td><td class="funcname"><a class="funcname" href="#TString:Format"><span class="baseclass">TString::</span>Format</a>(<span class="keyword">const</span> <span class="keyword">char</span>* fmt)</td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:GetInitialCapacity"><span class="baseclass">TString::</span>GetInitialCapacity</a>()</td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:GetMaxWaste"><span class="baseclass">TString::</span>GetMaxWaste</a>()</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#KVString:GetNValues">GetNValues</a>(<a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a> delim)</td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:GetResizeIncrement"><span class="baseclass">TString::</span>GetResizeIncrement</a>()</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:Gets"><span class="baseclass">TString::</span>Gets</a>(FILE* fp, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> chop = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#UInt_t">UInt_t</a></td><td class="funcname"><a class="funcname" href="#TString:Hash"><span class="baseclass">TString::</span>Hash</a>(<a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp = kExact) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#UInt_t">UInt_t</a></td><td class="funcname"><a class="funcname" href="#TString:Hash@1"><span class="baseclass">TString::</span>Hash</a>(<span class="keyword">const</span> <span class="keyword">void</span>* txt, <a href="./ListOfTypes.html#Int_t">Int_t</a> ntxt)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Index@4"><span class="baseclass">TString::</span>Index</a>(<span class="keyword">const</span> TRegexp&amp; pat, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> i = 0) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Index@6"><span class="baseclass">TString::</span>Index</a>(TPRegexp&amp; pat, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> i = 0) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Index"><span class="baseclass">TString::</span>Index</a>(<span class="keyword">const</span> <span class="keyword">char</span>* s, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> i = 0, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp = kExact) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Index@1"><span class="baseclass">TString::</span>Index</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> i = 0, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp = kExact) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Index@5"><span class="baseclass">TString::</span>Index</a>(<span class="keyword">const</span> TRegexp&amp; pat, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a>* ext, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> i = 0) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Index@7"><span class="baseclass">TString::</span>Index</a>(TPRegexp&amp; pat, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a>* ext, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> i = 0) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Index@2"><span class="baseclass">TString::</span>Index</a>(<span class="keyword">const</span> <span class="keyword">char</span>* pat, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> patlen, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> i, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Index@3"><span class="baseclass">TString::</span>Index</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; pat, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> patlen, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> i, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:InitialCapacity"><span class="baseclass">TString::</span>InitialCapacity</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> ic = 15)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Insert"><span class="baseclass">TString::</span>Insert</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> pos, <span class="keyword">const</span> <span class="keyword">char</span>* cs)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Insert@2"><span class="baseclass">TString::</span>Insert</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> pos, <span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Insert@1"><span class="baseclass">TString::</span>Insert</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> pos, <span class="keyword">const</span> <span class="keyword">char</span>* cs, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Insert@3"><span class="baseclass">TString::</span>Insert</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> pos, <span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n)</td></tr>
<tr class="func"><td class="funcret">virtual TClass*</td><td class="funcname"><a class="funcname" href="#KVString:IsA">IsA</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:IsAlnum"><span class="baseclass">TString::</span>IsAlnum</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:IsAlpha"><span class="baseclass">TString::</span>IsAlpha</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:IsAscii"><span class="baseclass">TString::</span>IsAscii</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:IsBin"><span class="baseclass">TString::</span>IsBin</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:IsDec"><span class="baseclass">TString::</span>IsDec</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:IsDigit"><span class="baseclass">TString::</span>IsDigit</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:IsFloat"><span class="baseclass">TString::</span>IsFloat</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:IsHex"><span class="baseclass">TString::</span>IsHex</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:IsInBaseN"><span class="baseclass">TString::</span>IsInBaseN</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> base) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:IsNull"><span class="baseclass">TString::</span>IsNull</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:IsOct"><span class="baseclass">TString::</span>IsOct</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:IsWhitespace"><span class="baseclass">TString::</span>IsWhitespace</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">static <a href="./KVString.html">KVString</a></td><td class="funcname"><a class="funcname" href="#KVString:Itoa">Itoa</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> value, <a href="./ListOfTypes.html#Int_t">Int_t</a> base)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Last"><span class="baseclass">TString::</span>Last</a>(<span class="keyword">char</span> c) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Length"><span class="baseclass">TString::</span>Length</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">static <a href="./KVString.html">KVString</a></td><td class="funcname"><a class="funcname" href="#KVString:LLtoa">LLtoa</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> value, <a href="./ListOfTypes.html#Int_t">Int_t</a> base)</td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#KVString:Match">Match</a>(<a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a> pattern)</td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:MaxWaste"><span class="baseclass">TString::</span>MaxWaste</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> mw = 15)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:MaybeRegexp"><span class="baseclass">TString::</span>MaybeRegexp</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:MaybeWildcard"><span class="baseclass">TString::</span>MaybeWildcard</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a></td><td class="funcname"><a class="funcname" href="#TString:MD5"><span class="baseclass">TString::</span>MD5</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./KVString.html">KVString</a></td><td class="funcname"><a class="funcname" href="#KVString:Next">Next</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> strip_whitespace = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">const</span> <span class="keyword">char</span>*</td><td class="funcname"><a class="funcname" href="#TString:operator_const_char*"><span class="baseclass">TString::</span>operator const char*</a>() <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">char</span>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator()"><span class="baseclass">TString::</span>operator()</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> i)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">char</span></td><td class="funcname"><a class="funcname" href="#TString:operator()@1"><span class="baseclass">TString::</span>operator()</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> i) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">TSubString</td><td class="funcname"><a class="funcname" href="#TString:operator()@3"><span class="baseclass">TString::</span>operator()</a>(<span class="keyword">const</span> TRegexp&amp; re) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">TSubString</td><td class="funcname"><a class="funcname" href="#TString:operator()@5"><span class="baseclass">TString::</span>operator()</a>(TPRegexp&amp; re) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">TSubString</td><td class="funcname"><a class="funcname" href="#TString:operator()@2"><span class="baseclass">TString::</span>operator()</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> start, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> len) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">TSubString</td><td class="funcname"><a class="funcname" href="#TString:operator()@4"><span class="baseclass">TString::</span>operator()</a>(<span class="keyword">const</span> TRegexp&amp; re, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> start) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">TSubString</td><td class="funcname"><a class="funcname" href="#TString:operator()@6"><span class="baseclass">TString::</span>operator()</a>(TPRegexp&amp; re, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> start) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator+_"><span class="baseclass">TString::</span>operator+=</a>(<span class="keyword">const</span> <span class="keyword">char</span>* cs)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator+_@1"><span class="baseclass">TString::</span>operator+=</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator+_@2"><span class="baseclass">TString::</span>operator+=</a>(<span class="keyword">char</span> c)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator+_@3"><span class="baseclass">TString::</span>operator+=</a>(<a href="./ListOfTypes.html#Short_t">Short_t</a> i)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator+_@4"><span class="baseclass">TString::</span>operator+=</a>(<a href="./ListOfTypes.html#UShort_t">UShort_t</a> i)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator+_@5"><span class="baseclass">TString::</span>operator+=</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> i)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator+_@6"><span class="baseclass">TString::</span>operator+=</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> i)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator+_@7"><span class="baseclass">TString::</span>operator+=</a>(<a href="./ListOfTypes.html#Long_t">Long_t</a> i)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator+_@8"><span class="baseclass">TString::</span>operator+=</a>(<a href="./ListOfTypes.html#ULong_t">ULong_t</a> i)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator+_@9"><span class="baseclass">TString::</span>operator+=</a>(<a href="./ListOfTypes.html#Float_t">Float_t</a> f)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator+_@10"><span class="baseclass">TString::</span>operator+=</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> f)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator+_@11"><span class="baseclass">TString::</span>operator+=</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> l)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator+_@12"><span class="baseclass">TString::</span>operator+=</a>(<a href="./ListOfTypes.html#ULong64_t">ULong64_t</a> ul)</td></tr>
<tr class="func"><td class="funcret"><a href="./KVString.html">KVString</a>&amp;</td><td class="funcname"><a class="funcname" href="#KVString:operator_">operator=</a>(<span class="keyword">const</span> <a href="./KVString.html">KVString</a>&amp; s)</td></tr>
<tr class="func"><td class="funcret"><a href="./KVString.html">KVString</a>&amp;</td><td class="funcname"><a class="funcname" href="#KVString:operator_@1">operator=</a>(<span class="keyword">const</span> <span class="keyword">char</span>* s)</td></tr>
<tr class="func"><td class="funcret"><a href="./KVString.html">KVString</a>&amp;</td><td class="funcname"><a class="funcname" href="#KVString:operator_@2">operator=</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">char</span>&amp;</td><td class="funcname"><a class="funcname" href="#TString:operator[]"><span class="baseclass">TString::</span>operator[]</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> i)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">char</span></td><td class="funcname"><a class="funcname" href="#TString:operator[]@1"><span class="baseclass">TString::</span>operator[]</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> i) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Prepend"><span class="baseclass">TString::</span>Prepend</a>(<span class="keyword">const</span> <span class="keyword">char</span>* cs)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Prepend@2"><span class="baseclass">TString::</span>Prepend</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Prepend@1"><span class="baseclass">TString::</span>Prepend</a>(<span class="keyword">const</span> <span class="keyword">char</span>* cs, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Prepend@3"><span class="baseclass">TString::</span>Prepend</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Prepend@4"><span class="baseclass">TString::</span>Prepend</a>(<span class="keyword">char</span> c, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> rep = 1)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TString:Puts"><span class="baseclass">TString::</span>Puts</a>(FILE* fp)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#KVString:RandomLetterSequence">RandomLetterSequence</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> length)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TString:ReadBuffer"><span class="baseclass">TString::</span>ReadBuffer</a>(<span class="keyword">char</span>*&amp; buffer)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#istream">istream</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:ReadFile"><span class="baseclass">TString::</span>ReadFile</a>(<a href="./ListOfTypes.html#istream">istream</a>&amp; str)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#istream">istream</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:ReadLine"><span class="baseclass">TString::</span>ReadLine</a>(<a href="./ListOfTypes.html#istream">istream</a>&amp; str, <a href="./ListOfTypes.html#Bool_t">Bool_t</a> skipWhite = <a href="./ListOfTypes.html#Bool_t">kTRUE</a>)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#istream">istream</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:ReadString@1"><span class="baseclass">TString::</span>ReadString</a>(<a href="./ListOfTypes.html#istream">istream</a>&amp; str)</td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>*</td><td class="funcname"><a class="funcname" href="#TString:ReadString"><span class="baseclass">TString::</span>ReadString</a>(TBuffer&amp; b, <span class="keyword">const</span> TClass* clReq)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#istream">istream</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:ReadToDelim"><span class="baseclass">TString::</span>ReadToDelim</a>(<a href="./ListOfTypes.html#istream">istream</a>&amp; str, <span class="keyword">char</span> delim = '\n')</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#istream">istream</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:ReadToken"><span class="baseclass">TString::</span>ReadToken</a>(<a href="./ListOfTypes.html#istream">istream</a>&amp; str)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Remove"><span class="baseclass">TString::</span>Remove</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> pos)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Remove@1"><span class="baseclass">TString::</span>Remove</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> pos, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Remove@2"><span class="baseclass">TString::</span>Remove</a>(<a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::EStripType s, <span class="keyword">char</span> c)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#KVString:RemoveAllExtraWhiteSpace">RemoveAllExtraWhiteSpace</a>()</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Replace"><span class="baseclass">TString::</span>Replace</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> pos, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n, <span class="keyword">const</span> <span class="keyword">char</span>* cs)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Replace@2"><span class="baseclass">TString::</span>Replace</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> pos, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n, <span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Replace@1"><span class="baseclass">TString::</span>Replace</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> pos, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n, <span class="keyword">const</span> <span class="keyword">char</span>* s, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> ns)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:Replace@3"><span class="baseclass">TString::</span>Replace</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> pos, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n1, <span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n2)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:ReplaceAll"><span class="baseclass">TString::</span>ReplaceAll</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s1, <span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s2)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:ReplaceAll@1"><span class="baseclass">TString::</span>ReplaceAll</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s1, <span class="keyword">const</span> <span class="keyword">char</span>* s2)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:ReplaceAll@2"><span class="baseclass">TString::</span>ReplaceAll</a>(<span class="keyword">const</span> <span class="keyword">char</span>* s1, <span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s2)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:ReplaceAll@3"><span class="baseclass">TString::</span>ReplaceAll</a>(<span class="keyword">const</span> <span class="keyword">char</span>* s1, <span class="keyword">const</span> <span class="keyword">char</span>* s2)</td></tr>
<tr class="funcinh"><td class="funcret"><a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp;</td><td class="funcname"><a class="funcname" href="#TString:ReplaceAll@4"><span class="baseclass">TString::</span>ReplaceAll</a>(<span class="keyword">const</span> <span class="keyword">char</span>* s1, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> ls1, <span class="keyword">const</span> <span class="keyword">char</span>* s2, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> ls2)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TString:Resize"><span class="baseclass">TString::</span>Resize</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> n)</td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:ResizeIncrement"><span class="baseclass">TString::</span>ResizeIncrement</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> ri = 16)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#KVString:ShowMembers">ShowMembers</a>(TMemberInspector&amp;)</td></tr>
<tr class="funcinh"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#TString:Sizeof"><span class="baseclass">TString::</span>Sizeof</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="funcname"><a class="funcname" href="#KVString:Sscanf">Sscanf</a>(<span class="keyword">const</span> <a href="./ListOfTypes.html#Char_t">Char_t</a>* fmt)</td></tr>
<tr class="func"><td class="funcret">virtual <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#KVString:Streamer">Streamer</a>(TBuffer&amp;)</td></tr>
<tr class="func"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#KVString:StreamerNVirtual">StreamerNVirtual</a>(TBuffer&amp; ClassDef_StreamerNVirtual_b)</td></tr>
<tr class="funcinh"><td class="funcret">TSubString</td><td class="funcname"><a class="funcname" href="#TString:Strip"><span class="baseclass">TString::</span>Strip</a>(<a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::EStripType s = kTrailing, <span class="keyword">char</span> c = <span class="string">' '</span>) <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret"><a href="./KVString.html">KVString</a></td><td class="funcname"><a class="funcname" href="#KVString:StripAllExtraWhiteSpace">StripAllExtraWhiteSpace</a>() <span class="keyword">const</span></td></tr>
<tr class="func"><td class="funcret">virtual <a href="./KVString.html">KVString</a>&amp;</td><td class="funcname"><a class="funcname" href="#KVString:Substitute">Substitute</a>(<span class="keyword">const</span> <a href="./ListOfTypes.html#Char_t">Char_t</a> c1, <span class="keyword">const</span> <a href="./ListOfTypes.html#Char_t">Char_t</a> c2)</td></tr>
<tr class="funcinh"><td class="funcret">TSubString</td><td class="funcname"><a class="funcname" href="#TString:SubString"><span class="baseclass">TString::</span>SubString</a>(<span class="keyword">const</span> <span class="keyword">char</span>* pat, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> start = 0, <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::ECaseCompare cmp = kExact) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret">TObjArray*</td><td class="funcname"><a class="funcname" href="#TString:Tokenize"><span class="baseclass">TString::</span>Tokenize</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; delim) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="funcname"><a class="funcname" href="#TString:Tokenize@1"><span class="baseclass">TString::</span>Tokenize</a>(<a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; tok, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a>&amp; from, <span class="keyword">const</span> <span class="keyword">char</span>* delim = <span class="string">" "</span>) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TString:ToLower"><span class="baseclass">TString::</span>ToLower</a>()</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TString:ToUpper"><span class="baseclass">TString::</span>ToUpper</a>()</td></tr>
<tr class="func"><td class="funcret">static <a href="./KVString.html">KVString</a></td><td class="funcname"><a class="funcname" href="#KVString:UItoa">UItoa</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> value, <a href="./ListOfTypes.html#Int_t">Int_t</a> base)</td></tr>
<tr class="func"><td class="funcret">static <a href="./KVString.html">KVString</a></td><td class="funcname"><a class="funcname" href="#KVString:ULLtoa">ULLtoa</a>(<a href="./ListOfTypes.html#ULong64_t">ULong64_t</a> value, <a href="./ListOfTypes.html#Int_t">Int_t</a> base)</td></tr>
<tr class="funcinh"><td class="funcret">static <span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TString:WriteString"><span class="baseclass">TString::</span>WriteString</a>(TBuffer&amp; b, <span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>* a)</td></tr>

</table></div>
<div class="access" id="funcprot"><b>protected:</b>
<table class="func" id="tabfuncprot" cellspacing="0">
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:AdjustCapacity"><span class="baseclass">TString::</span>AdjustCapacity</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> oldCap, <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> newCap)</td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Align"><span class="baseclass">TString::</span>Align</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> s)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TString:AssertElement"><span class="baseclass">TString::</span>AssertElement</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> nc) <span class="keyword">const</span></td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TString:Clobber"><span class="baseclass">TString::</span>Clobber</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> nc)</td></tr>
<tr class="funcinh"><td class="funcret"><span class="keyword">void</span></td><td class="funcname"><a class="funcname" href="#TString:InitChar"><span class="baseclass">TString::</span>InitChar</a>(<span class="keyword">char</span> c)</td></tr>
<tr class="funcinh"><td class="funcret">static <a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a></td><td class="funcname"><a class="funcname" href="#TString:Recommend"><span class="baseclass">TString::</span>Recommend</a>(<a href="./ListOfTypes.html#Ssiz_t">Ssiz_t</a> s)</td></tr>

</table></div>
</div>

<div id="datamembers">
<h2><a name="KVString:Data_Members"></a>Data Members</h2>
<div class="access" id="enumpubl"><b>public:</b>
<table class="data" id="tabenumpubl" cellspacing="0">
<tr class="datainh"><td class="datatype">enum <span class="baseclass">TString::</span><i>[unnamed]</i> { </td><td class="dataname"><a href="#TString:kAlignment">kAlignment</a></td><td></td></tr>
<tr class="datainh"><td class="datatype">};</td><td></td><td></td></tr>
<tr class="datainh"><td class="datatype">enum <span class="baseclass">TString::</span>EStripType { </td><td class="dataname"><a href="#TString:kLeading">kLeading</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TString:kTrailing">kTrailing</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TString:kBoth">kBoth</a></td><td></td></tr>
<tr class="datainh"><td class="datatype">};</td><td></td><td></td></tr>
<tr class="datainh"><td class="datatype">enum <span class="baseclass">TString::</span>ECaseCompare { </td><td class="dataname"><a href="#TString:kExact">kExact</a></td><td></td></tr>
<tr class="datainh"><td class="datatype"></td><td class="dataname"><a href="#TString:kIgnoreCase">kIgnoreCase</a></td><td></td></tr>
<tr class="datainh"><td class="datatype">};</td><td></td><td></td></tr>

</table></div>
<div class="access" id="dataprot"><b>protected:</b>
<table class="data" id="tabdataprot" cellspacing="0">
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Bool_t">Bool_t</a></td><td class="dataname"><a name="KVString:fEndList"></a>fEndList</td><td class="datadesc">! used by Next() &amp; End() to iterate over list</td></tr>
<tr class="data"><td class="datatype"><a href="./ListOfTypes.html#Int_t">Int_t</a></td><td class="dataname"><a name="KVString:fIterIndex"></a>fIterIndex</td><td class="datadesc">! used by Next() to iterate over list</td></tr>
<tr class="data"><td class="datatype">auto_ptr&lt;TObjArray&gt;</td><td class="dataname"><a name="KVString:kObjArr"></a>kObjArr</td><td class="datadesc">!used by Next() to iterate over list</td></tr>

</table></div>
</div>
<h2><a id="KVString:Class_Charts"></a>Class Charts</h2>
<map name="MapKVString_Lib" id="MapKVString_Lib">
<area shape="rect" id="node1" href="LibraryDependencies.html" title="All Libraries" alt="" coords="318,369,390,399"/>
</map>
<div class="tabs">
<a id="imgKVString_Inh" class="tabsel" href="inh/KVString_Inh.png" onclick="javascript:return SetImg('Charts','inh/KVString_Inh.png');">Inheritance</a>
<a id="imgKVString_InhMem" class="tab" href="inhmem/KVString_InhMem.png" onclick="javascript:return SetImg('Charts','inhmem/KVString_InhMem.png');">Inherited Members</a>
<a id="imgKVString_Incl" class="tab" href="incl/KVString_Incl.png" onclick="javascript:return SetImg('Charts','incl/KVString_Incl.png');">Includes</a>
<a id="imgKVString_Lib" class="tab" href="lib/KVString_Lib.png" onclick="javascript:return SetImg('Charts','lib/KVString_Lib.png');">Libraries</a><br/>
</div><div class="classcharts"><div class="classchartswidth"></div>
<img id="Charts" alt="Class Charts" class="classcharts" usemap="#MapKVString_Inh" src="inh/KVString_Inh.png"/></div>
<h2>Function documentation</h2>
<div class="funcdoc"><span class="funcname"><a href="./KVString.html">KVString</a>&amp; <a class="funcname" name="KVString:Substitute" href="src/KVString.cxx.html#Xb7S7D">Substitute</a>(<span class="keyword">const</span> <a href="./ListOfTypes.html#Char_t">Char_t</a> c1, <span class="keyword">const</span> <a href="./ListOfTypes.html#Char_t">Char_t</a> c2)</span><br />
<div class="funccomm"><pre><a href="./#TString:Replace" title="TString&amp; TString::Replace(Ssiz_t pos,Ssiz_t n,const char* cs) or overloads">Replace</a> every occurence of 'c1' with 'c2'
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="KVString:Sscanf" href="src/KVString.cxx.html#a2lRV">Sscanf</a>(<span class="keyword">const</span> <a href="./ListOfTypes.html#Char_t">Char_t</a>* fmt, ...)</span><br />
<div class="funccomm"><pre>A more strict implementation than the standard 'sscanf'
We require that any characters in the format string which are not format descriptors
(<span class="string">"%d"</span> etc.) be identical to the characters in this <a href="./KVString.html">KVString</a>

i.e. for a string <span class="string">"file6.root"</span>, sscanf(<span class="string">"file6.root"</span>, <span class="string">"file%d.root"</span>, &amp;some_integer) returns 1
but so does sscanf(<span class="string">"file6.root"</span>, <span class="string">"file%danything_you_want_here_i_dont_care"</span>, &amp;some_integer).

Use this method when you ONLY want <span class="string">"file%d.root"</span> to match <span class="string">"file6.root"</span>

Returns number of fields read from string

HANDLED FORMAT DESCRIPTORS

      %d   -  simple integer descriptor
      %3d   -  simple integer descriptor with length - only integers of correct length accepted
               (leading characters may be white space, i.e. '  4' for 4 written with '%3d')
      %03d   -  simple integer descriptor with length + zero padding - only integers of correct length accepted
               (leading characters may be zeroes, i.e. '004' for 4 written with '%03d')
      %*   -  just garbage, no argument required, it is not read. we ignore the rest of the string
                      and the rest of the format. this is not counted as a field to be read. i.e. <a href="./KVString.html#KVString:Sscanf" title="Int_t KVString::Sscanf(const Char_t* fmt)">Sscanf</a>(<span class="string">"%*"</span>)
                      gives 0 for any string, not because it doesn't match, but because there is nothing to read.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="KVString:Match" href="src/KVString.cxx.html#jHn1wE">Match</a>(<a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a> pattern)</span><br />
<div class="funccomm"><pre> Check if pattern fit the considered string
 As in ls shell command the * symbol represents the non discriminant part
 of the pattern
 if no * is present in the pattern, the result correspond to <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>::<a href="./#TString:Contains" title="Bool_t TString::Contains(const char* s,TString::ECaseCompare cmp=kExact) or overloads">Contains</a> method
 Example <a href="./KVString.html">KVString</a> st(file_R45.dat);
 st.<a href="./KVString.html#KVString:Match" title="Bool_t KVString::Match(TString pattern)">Match</a>(<span class="string">"*"</span>) -&gt; <a href="./ListOfTypes.html#Bool_t">kTRUE</a>
 st.<a href="./KVString.html#KVString:Match" title="Bool_t KVString::Match(TString pattern)">Match</a>(<span class="string">"file"</span>) -&gt;<a href="./ListOfTypes.html#Bool_t">kTRUE</a>
 st.<a href="./KVString.html#KVString:Match" title="Bool_t KVString::Match(TString pattern)">Match</a>(<span class="string">"*file*R*"</span>) -&gt;<a href="./ListOfTypes.html#Bool_t">kTRUE</a>
 etc ....
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="KVString:Begin" href="src/KVString.cxx.html#obeZ5E">Begin</a>(<a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a> delim) const</span><br />
<div class="funccomm"><pre> <a href="./KVString.html#KVString:Begin" title="void KVString::Begin(TString delim)">Begin</a>(), <a href="./KVString.html#KVString:Next" title="KVString KVString::Next(Bool_t strip_whitespace=kFALSE)">Next</a>() and <a href="./KVString.html#KVString:End" title="Bool_t KVString::End()">End</a>() can be used to loop over items in
 a string separated by the delimiter character given as argument
 to <a href="./KVString.html#KVString:Begin" title="void KVString::Begin(TString delim)">Begin</a>().

 Example:
   <a href="./KVString.html">KVString</a> str(<span class="string">"First | Second | Third"</span>);
   str.<a href="./KVString.html#KVString:Begin" title="void KVString::Begin(TString delim)">Begin</a>(<span class="string">"|"</span>);
   while( !str.<a href="./KVString.html#KVString:End" title="Bool_t KVString::End()">End</a>() ){
     <a href="./ListOfTypes.html#ostream">cout</a> &lt;&lt; str.<a href="./KVString.html#KVString:Next" title="KVString KVString::Next(Bool_t strip_whitespace=kFALSE)">Next</a>().<a href="./#TString:Data" title="const char* TString::Data()">Data</a>() &lt;&lt; endl;
   }

 This will give the following output:

 <a href="./#TString:First" title="Ssiz_t TString::First(char c) or overloads">First</a>
  Second
  Third

 WARNING: If the delimiter character is not contained in the string,
 calling <a href="./KVString.html#KVString:Next" title="KVString KVString::Next(Bool_t strip_whitespace=kFALSE)">Next</a>() will return the entire contents of the string, after
 which <a href="./KVString.html#KVString:End" title="Bool_t KVString::End()">End</a>() will return <a href="./ListOfTypes.html#Bool_t">kTRUE</a>. This allows to parse strings containing
 variable numbers of parameters separated by a delimiter which is only
 used with 2 or more parameters, i.e.:

      <span class="string">"par1|par2|par3"</span> -&gt; <span class="string">"par1"</span> <span class="string">"par2"</span> <span class="string">"par3"</span>
      <span class="string">"par1"</span>           -&gt; <span class="string">"par1"</span>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Bool_t">Bool_t</a> <a class="funcname" name="KVString:End" href="src/KVString.cxx.html#QfxIS">End</a>() const</span><br />
<div class="funccomm"><pre> <a href="./KVString.html#KVString:Begin" title="void KVString::Begin(TString delim)">Begin</a>(), <a href="./KVString.html#KVString:Next" title="KVString KVString::Next(Bool_t strip_whitespace=kFALSE)">Next</a>() and <a href="./KVString.html#KVString:End" title="Bool_t KVString::End()">End</a>() can be used to loop over items in
 a string separated by the delimiter character given as argument
 to <a href="./KVString.html#KVString:Begin" title="void KVString::Begin(TString delim)">Begin</a>().

 Example:
   <a href="./KVString.html">KVString</a> str(<span class="string">"First | Second | Third"</span>);
   str.<a href="./KVString.html#KVString:Begin" title="void KVString::Begin(TString delim)">Begin</a>(<span class="string">"|"</span>);
   while( !str.<a href="./KVString.html#KVString:End" title="Bool_t KVString::End()">End</a>() ){
     <a href="./ListOfTypes.html#ostream">cout</a> &lt;&lt; str.<a href="./KVString.html#KVString:Next" title="KVString KVString::Next(Bool_t strip_whitespace=kFALSE)">Next</a>().<a href="./#TString:Data" title="const char* TString::Data()">Data</a>() &lt;&lt; endl;
   }

 This will give the following output:

 <a href="./#TString:First" title="Ssiz_t TString::First(char c) or overloads">First</a>
  Second
  Third
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./KVString.html">KVString</a> <a class="funcname" name="KVString:Next" href="src/KVString.cxx.html#ECVZFC">Next</a>(<a href="./ListOfTypes.html#Bool_t">Bool_t</a> strip_whitespace = <a href="./ListOfTypes.html#Bool_t">kFALSE</a>) const</span><br />
<div class="funccomm"><pre> <a href="./KVString.html#KVString:Begin" title="void KVString::Begin(TString delim)">Begin</a>(), <a href="./KVString.html#KVString:Next" title="KVString KVString::Next(Bool_t strip_whitespace=kFALSE)">Next</a>() and <a href="./KVString.html#KVString:End" title="Bool_t KVString::End()">End</a>() can be used to loop over items in
 a string separated by the delimiter character given as argument
 to <a href="./KVString.html#KVString:Begin" title="void KVString::Begin(TString delim)">Begin</a>().
 If strip_whitespace=<a href="./ListOfTypes.html#Bool_t">kTRUE</a> (default is <a href="./ListOfTypes.html#Bool_t">kFALSE</a>), any leading or
 trailing whitespace is removed from each item.

 Example:
   <a href="./KVString.html">KVString</a> str(<span class="string">"First | Second | Third"</span>);
   str.<a href="./KVString.html#KVString:Begin" title="void KVString::Begin(TString delim)">Begin</a>(<span class="string">"|"</span>);
   while( !str.<a href="./KVString.html#KVString:End" title="Bool_t KVString::End()">End</a>() ){
     <a href="./ListOfTypes.html#ostream">cout</a> &lt;&lt; str.<a href="./KVString.html#KVString:Next" title="KVString KVString::Next(Bool_t strip_whitespace=kFALSE)">Next</a>(<a href="./ListOfTypes.html#Bool_t">kTRUE</a>).<a href="./#TString:Data" title="const char* TString::Data()">Data</a>() &lt;&lt; endl;
   }

 This will give the following output:

 <a href="./#TString:First" title="Ssiz_t TString::First(char c) or overloads">First</a>
 Second
 Third

 whereas if <a href="./KVString.html#KVString:Next" title="KVString KVString::Next(Bool_t strip_whitespace=kFALSE)">Next</a>() is used (i.e. strip_whitespace=<a href="./ListOfTypes.html#Bool_t">kFALSE</a>),
 this gives:

 <a href="./#TString:First" title="Ssiz_t TString::First(char c) or overloads">First</a>
  Second
  Third
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./ListOfTypes.html#Int_t">Int_t</a> <a class="funcname" name="KVString:GetNValues" href="src/KVString.cxx.html#dDRHCB">GetNValues</a>(<a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a> delim)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./KVString.html">KVString</a> <a class="funcname" name="KVString:Itoa" href="src/KVString.cxx.html#iAa67C">Itoa</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> value, <a href="./ListOfTypes.html#Int_t">Int_t</a> base)</span><br />
<div class="funccomm"><pre> Converts an <a href="./ListOfTypes.html#Int_t">Int_t</a> to a <a href="./KVString.html">KVString</a> with respect to the base specified (2-36).
 Thus it is an enhanced version of sprintf (adapted from versions 0.4 of
 http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).
 Usage: the following statement produce the same output, namely <span class="string">"1111"</span>
   std::<a href="./ListOfTypes.html#ostream">cout</a> &lt;&lt; <a href="./KVString.html">KVString</a>::<a href="./KVString.html#KVString:Itoa" title="KVString KVString::Itoa(Int_t value,Int_t base)">Itoa</a>(15,2) ;
   std::<a href="./ListOfTypes.html#ostream">cout</a> &lt;&lt; <a href="./KVString.html">KVString</a>::<a href="./KVString.html#KVString:Itoa" title="KVString KVString::Itoa(Int_t value,Int_t base)">Itoa</a>(0xF,2) ; /// 0x prefix to handle hex
   std::<a href="./ListOfTypes.html#ostream">cout</a> &lt;&lt; <a href="./KVString.html">KVString</a>::<a href="./KVString.html#KVString:Itoa" title="KVString KVString::Itoa(Int_t value,Int_t base)">Itoa</a>(017,2) ; /// 0  prefix to handle oct
 In case of error returns the <span class="string">"!"</span> string.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./KVString.html">KVString</a> <a class="funcname" name="KVString:UItoa" href="src/KVString.cxx.html#Gd32RE">UItoa</a>(<a href="./ListOfTypes.html#UInt_t">UInt_t</a> value, <a href="./ListOfTypes.html#Int_t">Int_t</a> base)</span><br />
<div class="funccomm"><pre> Converts a <a href="./ListOfTypes.html#UInt_t">UInt_t</a> (twice the range of an <a href="./ListOfTypes.html#Int_t">Int_t</a>) to a <a href="./KVString.html">KVString</a> with respect
 to the base specified (2-36). Thus it is an enhanced version of sprintf
 (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).
 In case of error returns the <span class="string">"!"</span> string.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./KVString.html">KVString</a> <a class="funcname" name="KVString:LLtoa" href="src/KVString.cxx.html#h6dPfC">LLtoa</a>(<a href="./ListOfTypes.html#Long64_t">Long64_t</a> value, <a href="./ListOfTypes.html#Int_t">Int_t</a> base)</span><br />
<div class="funccomm"><pre> Converts a <a href="./ListOfTypes.html#Long64_t">Long64_t</a> to a <a href="./KVString.html">KVString</a> with respect to the base specified (2-36).
 Thus it is an enhanced version of sprintf (adapted from versions 0.4 of
 http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).
 In case of error returns the <span class="string">"!"</span> string.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./KVString.html">KVString</a> <a class="funcname" name="KVString:ULLtoa" href="src/KVString.cxx.html#molsOC">ULLtoa</a>(<a href="./ListOfTypes.html#ULong64_t">ULong64_t</a> value, <a href="./ListOfTypes.html#Int_t">Int_t</a> base)</span><br />
<div class="funccomm"><pre> Converts a <a href="./ListOfTypes.html#ULong64_t">ULong64_t</a> (twice the range of an <a href="./ListOfTypes.html#Long64_t">Long64_t</a>) to a <a href="./KVString.html">KVString</a> with
 respect to the base specified (2-36). Thus it is an enhanced version of
 sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).
 In case of error returns the <span class="string">"!"</span> string.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./KVString.html">KVString</a> <a class="funcname" name="KVString:BaseConvert" href="src/KVString.cxx.html#JCEz2E">BaseConvert</a>(<span class="keyword">const</span> <a href="./KVString.html">KVString</a>&amp; s_in, <a href="./ListOfTypes.html#Int_t">Int_t</a> base_in, <a href="./ListOfTypes.html#Int_t">Int_t</a> base_out)</span><br />
<div class="funccomm"><pre> Converts string from base base_in to base base_out. Supported bases
 are 2-36. At most 64 bit data can be converted.
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="KVString:RemoveAllExtraWhiteSpace" href="src/KVString.cxx.html#GWB8UE">RemoveAllExtraWhiteSpace</a>()</span><br />
<div class="funccomm"><pre> <a href="./#TString:Remove" title="TString&amp; TString::Remove(Ssiz_t pos) or overloads">Remove</a> any superfluous whitespace (or tabs or newlines) from this string (modifies string)
 i.e. transform <span class="string">"   Mary               Had\tA   Little \n          Laaaaaaaaaaaaaaaaaamb"</span>
 into <span class="string">"Mary Had A Little Lamb"</span>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./KVString.html">KVString</a> <a class="funcname" name="KVString:StripAllExtraWhiteSpace" href="src/KVString.cxx.html#zyCEGE">StripAllExtraWhiteSpace</a>() const</span><br />
<div class="funccomm"><pre> <a href="./#TString:Remove" title="TString&amp; TString::Remove(Ssiz_t pos) or overloads">Remove</a> any superfluous whitespace (or tabs or newlines) from string (does not modify string)
 i.e. transform <span class="string">"   Mary               Had\tA   Little \n          Laaaaaaaaaaaaaaaaaamb"</span>
 into <span class="string">"Mary Had A Little Lamb"</span>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./KVString.html">KVString</a>&amp; <a class="funcname" name="KVString:FindCommonCharacters" href="src/KVString.cxx.html#zinmcD">FindCommonCharacters</a>(<span class="keyword">const</span> TCollection* , <span class="keyword">const</span> <span class="keyword">char</span> bug = <span class="string">'*'</span>)</span><br />
<div class="funccomm"><pre> list is a collection of objects with names
 this method generates a string containing all characters which appear
 in every name in the list, the others are replaced by the 'bug' character.

 example:
   list contains a set of TNamed with names:
        run_0001.root
        run_0002.root

        run_0099.root

 then toto.<a href="./KVString.html#KVString:FindCommonCharacters" title="KVString&amp; KVString::FindCommonCharacters(const TCollection* ,const char bug='*')">FindCommonCharacters</a>(list) will produce toto=<span class="string">"run_00*.root"</span>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><a href="./KVString.html">KVString</a>&amp; <a class="funcname" name="KVString:FindCommonTitleCharacters" href="src/KVString.cxx.html#lC4fQD">FindCommonTitleCharacters</a>(<span class="keyword">const</span> TCollection* , <span class="keyword">const</span> <span class="keyword">char</span> bug = <span class="string">'*'</span>)</span><br />
<div class="funccomm"><pre> list is a collection of objects with titles
 this method generates a string containing all characters which appear
 in every title in the list, the others are replaced by the 'bug' character.

 example:
   list contains a set of TNamed with titles:
        run_0001.root
        run_0002.root

        run_0099.root

 then toto.<a href="./KVString.html#KVString:FindCommonCharacters" title="KVString&amp; KVString::FindCommonCharacters(const TCollection* ,const char bug='*')">FindCommonCharacters</a>(list) will produce toto=<span class="string">"run_00*.root"</span>
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"><span class="keyword">void</span> <a class="funcname" name="KVString:RandomLetterSequence" href="src/KVString.cxx.html#IHtvRE">RandomLetterSequence</a>(<a href="./ListOfTypes.html#Int_t">Int_t</a> length)</span><br />
<div class="funccomm"><pre> Generate a random sequence of upper- and lower-case letters
 of given length
</pre></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="KVString:KVString@4" href="src/KVString.cxx.html#N6AtcB">KVString</a>(<a href="./ListOfTypes.html#Double_t">Double_t</a> value, <a href="./ListOfTypes.html#Double_t">Double_t</a> error)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./KVString.html">KVString</a>&amp; <a class="funcname" name="KVString:operator_" href="src/KVString.h.html#j.Evd">operator=</a>(<span class="keyword">const</span> <a href="./KVString.html">KVString</a>&amp; s)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./KVString.html">KVString</a>&amp; <a class="funcname" name="KVString:operator_@2" href="src/KVString.h.html#rWTB3D">operator=</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s)</span><br />
</div>
<div class="funcdoc"><span class="funcname"><a href="./KVString.html">KVString</a>&amp; <a class="funcname" name="KVString:operator_@1" href="src/KVString.h.html#Nc8Yb">operator=</a>(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span><br />
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="KVString:KVString" href="src/KVString.h.html#IwW3bC">KVString</a>()</span><br />

<div class="code"><code class="inlinecode">{}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="KVString:KVString@1" href="src/KVString.h.html#nIyHOE">KVString</a>(<span class="keyword">const</span> <a href="./ListOfTypes.html#Char_t">Char_t</a>* s)</span><br />

<div class="code"><code class="inlinecode">{}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="KVString:KVString@2" href="src/KVString.h.html#WGexTE">KVString</a>(<span class="keyword">const</span> <a href="./#TString:TString" title="TString TString::TString(const char* a1,Ssiz_t n1,const char* a2,Ssiz_t n2) or overloads">TString</a>&amp; s)</span><br />

<div class="code"><code class="inlinecode">{}</code></div>
<div style="clear:both;"></div>
</div>
<div class="funcdoc"><span class="funcname"> <a class="funcname" name="KVString:KVString@3" href="src/KVString.h.html#pg.J9C">KVString</a>(<span class="keyword">const</span> <a href="./KVString.html">KVString</a>&amp; s)</span><br />

<div class="code"><code class="inlinecode">{}</code></div>
<div style="clear:both;"></div>
</div>

<br />
<!--SIGNATURE-->
<div id="footer">

<em>&raquo; Last changed: Tue Feb 28 17:22:44 2017 </em><em>&raquo; Last generated: 2017-02-28 17:22</em><br />
<em>This page has been automatically generated.</em>
</div>
</div>
</body>
</html>
